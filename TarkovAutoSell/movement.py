# movement class w/methods

import time
import json
import pygame
import pyautogui
import numpy as np
import Functions
import random
import operator
import math
import statistics

pyautogui.FAILSAFE = False
pyautogui.PAUSE = 0
clock = pygame.time.Clock()

# check statistics.median_grouped()

#self.currentCurve = last recorded curve
#self.keptCurves = temporary list of curves saved in session with keep()
#self.AllCurves = list of saves curves, cleared when save is called

# ATM whenever save() function is called, it sets Allcurves = 0.


class Movement():

    def __init__(self):
        self.frame = 0
        self.x = 0
        self.y = 0
        self.currentCurve = []
        self.KeptCurves = []
        self.savedCurves = []
        self.recordActive = False
        self.moving = False
        self.active = True
        self.startingPos = (0, 0)
        self.RNGdistance = (0, 0)
        self.RNGrolls = []                                          # List of all RNG rolls through mouse movements
        self.startingPositions = []                                 # List of all curve starting positions

        # position booleans
        self.FilterByItemPos = False

    def record(self):

        if self.recordActive == True:
            # Previous curve deleted, needs to be saved

            [x, y] = pygame.mouse.get_pos()
            self.currentCurve.append([x, y])
        if self.recordActive == False:
            pass

    def Keep(self):
        '''
        appends last recorded curve to KeptCurves List
        '''
        # create object with curve x,y
        if self.recordActive == True:
            print('Finish recording first')
        if self.recordActive == False:
            i = Movement()  # will this calculate ci ?
            print(self.currentCurve)
            i.currentCurve = self.currentCurve
            self.KeptCurves.append(i)
            print(self.KeptCurves)
            print('Curve Kept')

    def save(self):
        '''
        Saves List of kept movements, codes them with json
        :return: List[array]
        '''
        AllCurves = []
        for i in self.KeptCurves:
            f = open("curves.txt", "w+")
            AllCurves.append(i.currentCurve)
        print(AllCurves)
        StringCurves = json.dumps(AllCurves)
        try:
            f.write(StringCurves)
        except UnboundLocalError:
            print('''Couldn't write to curves.txt, self.currentCurve is empty - hasn't been kept''')

    def move(self):
        '''
        Moves along array generated by user, using pyautogui,
        stopping at the end, if
        :return: print('hi')
        '''
        if self.moving == True:
            try:
                pyautogui.moveTo(((self.currentCurve[self.frame][0]), (self.currentCurve[self.frame][1])))
                self.frame += 1
            except IndexError:
                print('Reached end of curve')
                self.moving = False
        if self.moving == False:
            self.frame = 0  # might not be needed - attribute

    def MoveTo(self, start, dest, curve):
        '''
        Aligns a pre-defined curve with specified start and destination, for a movement object,
        intiates a while loop to move through curve coordinates stopped when
        destination is reached
        :return:
        '''
        self.align(start, dest, curve)
        self.moving = True
        while self.active == True:
            clock.tick(60)

            self.move()

            if self.moving == False and pyautogui.position() == self.dest:
                print('Moved and reached')
                break


    def MoveToRandom(self, start, curve, nonrngXYdistance, xrange, yrange):
        '''
        Uses a start defined from last mouse movement, a pre-defined curve and defines a destination.
        Then moves along such curve.
        :param nonrngXYdistance: (x,y)
        :param start: (x,y)
        :param curve: array
        :param xrange: range of x co-ordinates - (xmin,xmax)
        :param yrange: range of y co-ordinates - (ymin,ymax)
        :return: None. But sets self.startingPos = dest
        '''
        self.RNGdistance = Functions.ChooseRandomInt(xrange, yrange)
        print(self.RNGdistance)
        self.RNGrolls.append(self.RNGdistance)
        dest = tuple(map(lambda x, y: x + y, self.RNGdistance, nonrngXYdistance))
        self.MoveTo(start, dest, curve)

        self.startingPos = dest
        self.startingPositions.append(self.startingPos)

        # changes position after RNG selection
        self.PositionRule()

    def PositionRule(self):
        '''
        Of the form: 'if bool': ' change destination position '
        :return:
        '''
        # Each rule must be mutually exclusive to not violate self.startingPosition list index selection
        # though must will act on self.startingPosition[-1] - (latest generated position)

        if self.FilterByItemPos == True and self.RNGrolls[1][0] <= 39:
            # activates if in left third of 'search' button
            # 2/3 chance that it reduces NET distance travelled by 2/3
            print('in the left third')
            rand = random.randint(0, 2)
            if rand <= 1:
                print('FilterByItemPos roll Failed')
            if rand > 1:
                print('rolled FilterByItemPos Passed')
                print(self.RNGdistance)
                RuleShift1 = tuple(map(lambda x: operator.floordiv(x, (3/2)), self.RNGdistance))
                print(RuleShift1)
                print(self.startingPositions[-1])
                self.startingPositions[-1] = tuple(map(lambda x, y: x - y, self.startingPos[-1], RuleShift1)) # Since RuleShift1 is negative: -(-)
                print(self.startingPositions[-1])

    def align(self, item, dest, arrayN):
        '''
        Takes an existing movement array, shifts it to a startpoint
        (an FiR item's position),scales it by 'k',to produce a new movement
        array, reaching the destination 'dest'
        :param: item(x,y), dest(x,y), arrayN(array)
        '''
        # Working out initial shift
        shiftx = (item[0] - arrayN[0][0])
        shift = ((item[0] - arrayN[0][0]), (item[1] - arrayN[0][1]))

        # Distance to button, destination of xn
        dest1 = dest
        dist1 = ((dest1[0] - item[0]), (dest1[1] - item[1]))

        # Distance to last x1, current destination of x1
        dest2 = ((arrayN[-1][0]), (arrayN[-1][1]))
        dist2 = (((arrayN[-1][0]) + shift[0] - item[0]), ((arrayN[-1][1]) + shift[1] - item[1]))

        # Calculating k and x1 array distance, centered at 0
        k = [(dist1[0] / dist2[0]), (dist1[1] / dist2[1])]
        distarray = (arrayN + shift - item)

        # Transforming x1 array distance by k, moving back to item
        xn0 = np.multiply(k, distarray)
        xn = np.add(xn0, item)

        # We now have xn - array of movement, centered at item
        self.currentCurve = xn
        self.dest = dest
        return self.currentCurve



' Notes '

# need to make all methods work on objects and absorb global into class attr.
# rather than use a global variable like:
# KeptCurves = 0

# seems better to store objects, rather than use just the x,y, since the
# objects have that as an attribute, + are needed to store other info
# as attributes, like rotation, initial x,y(?)










