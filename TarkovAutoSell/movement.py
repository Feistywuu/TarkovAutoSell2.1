# movement class w/methods

import time
import json
import os
import pygame
import pyautogui
import numpy as np

pyautogui.FAILSAFE = False
pyautogui.PAUSE = 0
clock = pygame.time.Clock()

os.chdir('''C:\\Users\\Philip\\Documents\\Programming\\Opencv\\TarkovAutoSell''')

# need to make all methods work on objects and absorb global into class attr.
# rather than use a global variable like:
KeptCurves = []


# seems better to store objects, rather than use just the x,y, since the
# objects have that as an attribute, + are needed to store other info
# as attributes, like rotation, initial x,y(?)

# maybe should be stored in a list, if wanted to refer to all

class Movement():

    def __init__(self):
        self.frame = 0
        self.x = 0
        self.y = 0
        self.savedCurves = []
        self.currentCurve = []
        self.recordActive = False
        self.moving = False
        self.active = True

    def record(self):

        if self.recordActive == True:
            # Previous curve deleted, needs to be saved

            [x, y] = pygame.mouse.get_pos()
            self.currentCurve.append([x, y])
        if self.recordActive == False:
            pass

    def Keep(self):
        '''
        appends last recorded curve to KeptCurves List
        '''
        # create object with curve x,y
        if self.recordActive == True:
            print('Finish recording first')
        if self.recordActive == False:
            i = Movement()  # will this calculate ci ?
            print(self.currentCurve)
            i.currentCurve = self.currentCurve
            KeptCurves.append(i)
            print(KeptCurves)
            print('Curve Kept')

    def move(self):
        '''
        Moves along array generated by user, using pyautogui,
        stopping at the end, if
        :return: print('hi')
        '''
        if self.moving == True:
            try:
                pyautogui.moveTo(((self.currentCurve[self.frame][0]), (self.currentCurve[self.frame][1])))
                self.frame += 1
            except IndexError:
                print('Reached end of curve')
                self.moving = False
        if self.moving == False:
            self.frame = 0  # might not be needed - attribute

    def save(self):
        '''
        Saves List of kept movements, codes them with json
        :return: List[array]
        '''
        AllCurves = []
        for i in KeptCurves:
            f = open("Curves.txt", "w+")
            AllCurves.append(i.currentCurve)
        print(AllCurves)
        StringCurves = json.dumps(AllCurves)
        f.write(StringCurves)

    def Oldsave(self):
        '''
        Keeps array of last mouse movement
        :return: List[array]
        '''
        f = open("Curves.txt", "w+")
        count = 1
        for i in KeptCurves:
            for j in range(len(i.currentCurve)):
                if j == 0:
                    f.write('%s\n' % ('Curve' + str(count) + ':'))
                    count += 1
                print(str(i.currentCurve[j]))
                f.write('%s\n' % str(i.currentCurve[j]))
                if j == len(i.currentCurve) - 1:
                    f.write('\n')
                    # f.write('%s\n' % 'New Curve:')

    def align(self, item, dest, arrayN):
        '''
        Takes an existing movement array, shifts it to a startpoint
        (an FiR item's position),scales it by 'k',to produce a new movement
        array, reaching the destination 'dest'
        :param: item(x,y), dest(x,y), arrayN(array)
        '''
        # Working out initial shift
        shiftx = (item[0] - arrayN[0][0])
        shift = ((item[0] - arrayN[0][0]), (item[1] - arrayN[0][1]))

        # Distance to button, destination of xn
        dest1 = dest
        dist1 = ((dest1[0] - item[0]), (dest1[1] - item[1]))

        # Distance to last x1, current destination of x1
        dest2 = ((arrayN[-1][0]), (arrayN[-1][1]))
        dist2 = (((arrayN[-1][0]) + shift[0] - item[0]), ((arrayN[-1][1]) + shift[1] - item[1]))

        # Calculating k and x1 array distance, centered at 0
        k = [(dist1[0] / dist2[0]), (dist1[1] / dist2[1])]
        distarray = (arrayN + shift - item)

        # Transforming x1 array distance by k, moving back to item
        xn0 = np.multiply(k, distarray)
        xn = np.add(xn0, item)

        # We now have xn - array of movement, centered at item
        self.currentCurve = xn
        self.dest = dest
        return self.currentCurve

    def MoveTo(self, start, dest, curve):
        '''
        Aligns a pre-defined curve with specified start and destination, for a movement object,
        intiates a while loop to move through curve coordinates stopped when
        destination is reached
        :return:
        '''
        self.align(start, dest, curve)
        self.moving = True
        while self.active == True:
            clock.tick(60)

            self.move()

            if self.moving == False and pyautogui.position() == self.dest:
                print('Moved and reached')
                break


